# Основные принципы объектно-ориентированного программирования.

## Абстракция
Принцип DRY - Dont repeate yourself подразумевает избегание повторений кода за счет вынесения их в переносимые конструкции, которые можно применить там, где это требуется. Это может быть сделано посредством наследования, декарирования, вынесения кода в отдельные методы для повторного вызова.

## понятие класса и объекта
объект - программная сущность наделенная состоянием (полями), имеющая четко определенный контракт взаимодействия в виде набора методов.
Класс является фабрикой объектов.

## инкапсуляция
Один из важнейших принципов, подразумевающих сокрытие данных, методов (внутренней логики работы класса) внутри самого класса. Иногда инкапсуляци рассматривается как размещение полей и методов класса внутри сущности, отдельно от сокрытия.
Инкапсуляция требуетсяд ля формирования четкого контракта взаимодействия, в котором не будет ничего лишнего для пользователя класса (или API), а все детали работы будут сокрыты.
Более обобщенно – инкапсуляцию разграничивает различные части программы друг от друга.

**Принцип одной отвественности** подразумевает что сущность будет отвечать лишь за что-то одно конкретное -> инкапсулировать стоит как можно меньше, не перегружая класс.

- паттерн getter setter и Java bean
- неизменяемость класса и приемущества по отношениею к getter setter pattern

## полиморфизм – одинообразная обработка данных разных типов.
Полиморфизм – это способность использовать обьект, зная лишь его контракт (интерфейс), не принимая во внимание его тип.
Например, пусть в системе есть 2 класса Warning и Error, оба реализовывают интерфейс Message { isError(); }
Обращаясь к объекту по интерфейсной ссылке мы лишь знаем поведение, описанное в контракте Message.

## наследование
Наследование это механизм позволяющий создавать объект на основе уже существующего, его стоит применять в ситуациях когда наследник *является* по своей сути родителем. Пример: администратор является пользователем системы. Наследник реализует весь интерфейс родителя и принимает его тип. Наследник может добавлять функциональность либо переопределять ее (полиморфизм).

Есть мнение что наследование приводит к перегрузке контракта и лучше использовать декорыторы, инкапсулируя объект суперкласса в наследника, вызавая его методы там, где это требуется. Главная концепция ооп - компоновка больших объектов из маленьких, при декораторах это так. При наследовании это скорее попытка сделать 1 большой объект - наследник с суммой всех полей / методов всех родителей. 

&nbsp;
<hr>

> [Список вопросов](Вопросы_ТПП.md)